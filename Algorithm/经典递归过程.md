# 经典递归过程

## 1.获取字符串全部子序列

这道题是一个满二叉树展开,设置String ans="",对于给定的每个字符，每个字符可以加入ans,也可以不加入ans,到达叶节点的时候返回ans，再通过set过滤筛选即可。

经典dfs版本:

```java
public String[] generatePermutation1 (String s) {
    char[] arr=s.toCharArray();
    StringBuilder sb=new StringBuilder();
    Set<String> set=new HashSet<>();
    getSubAllString(arr,0,sb,set);

    String[] ans=new String[set.size()];
    int index=0;
    for(String t:set) {
        ans[index++]=t;
    }
    return ans;
}
public static void getSubAllString(char[] arr,int index,StringBuilder sb,Set<String> set) {
    if(index==arr.length) {
        set.add(sb.toString());
        return;
    }
    getSubAllString(arr,index+1,sb,set);
    sb.append(arr[index]);
    getSubAllString(arr,index+1,sb,set);
    sb.deleteCharAt(sb.length()-1);
}
```

小优化，没有字符串的恢复状态的版本

```java
public String[] generatePermutation(String s) {
    char[] arr=s.toCharArray();
    char[] cop=new char[s.length()];
    Set<String> set=new HashSet<>();
    f2(arr,0,cop,0,set);

    String[] ans=new String[set.size()];
    int index=0;
    for(String t:set) {
        ans[index++]=t;
    }
    return ans;
}
public static void f2(char[] arr,int index,char[] cop,int size,Set<String> set) {
    if(index==arr.length) {
        set.add(String.valueOf(cop, 0, size));
        return;
    }
    f2(arr,index+1,cop,size,set);
    cop[size]=arr[index];
    f2(arr,index+1,cop,size+1,set);
}
```

这两个时间复杂度都是(O(2^n * n)因为到达每个叶子结点需要生成一个String

测试链接:https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a

## 2.返回数组所有子序列

返回数组中的所有子序列，不论顺序，但是不能重复

这道题本质和第一题一样，但是左神给出了一种在设计上就剪枝的思想:

1.首先将数组排序

2.相同的数假设一共有n个，从0个开始递归到n个

3.重复2直到终止条件

这个写法就没有将每个数展开，感觉很妙

```java
public List<List<Integer>> subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    int[] cop=new int[nums.length];
    List<List<Integer>> ans=new ArrayList<List<Integer>>();
    f(nums,0,cop,0,ans);
    return ans;
}
public void f(int[] nums,int index,int[] cop,int size, List<List<Integer>> ans) {
    if(index==nums.length) {
        List<Integer> list=new ArrayList<>();
        for(int i=0;i<size;i++) {
            list.add(cop[i]);
        }
        ans.add(list);
        return;
    }
    int j=index+1;
    while(j<nums.length && nums[index]==nums[j])j++;
    f(nums,j,cop,size,ans);
    for(int i=index;i<j;i++) {
        cop[size++]=nums[i];
        f(nums,j,cop,size,ans);
    }
}
```

时间复杂度都是(O(2^n * n) 因为最坏情况每个数都不同，都要展开，然后到达每个叶子结点需要生成一个List

测试链接:https://leetcode.cn/problems/subsets-ii/description/

