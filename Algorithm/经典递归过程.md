# 经典递归过程

## 1.获取字符串全部子序列

这道题是一个满二叉树展开,设置String ans="",对于给定的每个字符，每个字符可以加入ans,也可以不加入ans,到达叶节点的时候返回ans，再通过set过滤筛选即可。

经典dfs版本:

```java
public String[] generatePermutation1 (String s) {
    char[] arr=s.toCharArray();
    StringBuilder sb=new StringBuilder();
    Set<String> set=new HashSet<>();
    getSubAllString(arr,0,sb,set);

    String[] ans=new String[set.size()];
    int index=0;
    for(String t:set) {
        ans[index++]=t;
    }
    return ans;
}
public static void getSubAllString(char[] arr,int index,StringBuilder sb,Set<String> set) {
    if(index==arr.length) {
        set.add(sb.toString());
        return;
    }
    getSubAllString(arr,index+1,sb,set);
    sb.append(arr[index]);
    getSubAllString(arr,index+1,sb,set);
    sb.deleteCharAt(sb.length()-1);
}
```

小优化，没有字符串的恢复状态的版本

```java
public String[] generatePermutation(String s) {
    char[] arr=s.toCharArray();
    char[] cop=new char[s.length()];
    Set<String> set=new HashSet<>();
    f2(arr,0,cop,0,set);

    String[] ans=new String[set.size()];
    int index=0;
    for(String t:set) {
        ans[index++]=t;
    }
    return ans;
}
public static void f2(char[] arr,int index,char[] cop,int size,Set<String> set) {
    if(index==arr.length) {
        set.add(String.valueOf(cop, 0, size));
        return;
    }
    f2(arr,index+1,cop,size,set);
    cop[size]=arr[index];
    f2(arr,index+1,cop,size+1,set);
}
```

这两个时间复杂度都是(O(2^n * n)因为到达每个叶子结点需要生成一个String

测试链接:https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a

## 2.返回数组所有子序列

返回数组中的所有子序列，不论顺序，但是不能重复

这道题本质和第一题一样，但是左神给出了一种在设计上就剪枝的思想:

1.首先将数组排序

2.相同的数假设一共有n个，从0个开始递归到n个

3.重复2直到终止条件

这个写法就没有将每个数展开，感觉很妙

```java
public List<List<Integer>> subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    int[] cop=new int[nums.length];
    List<List<Integer>> ans=new ArrayList<List<Integer>>();
    f(nums,0,cop,0,ans);
    return ans;
}
public void f(int[] nums,int index,int[] cop,int size, List<List<Integer>> ans) {
    if(index==nums.length) {
        List<Integer> list=new ArrayList<>();
        for(int i=0;i<size;i++) {
            list.add(cop[i]);
        }
        ans.add(list);
        return;
    }
    int j=index+1;
    while(j<nums.length && nums[index]==nums[j])j++;
    f(nums,j,cop,size,ans);
    for(int i=index;i<j;i++) {
        cop[size++]=nums[i];
        f(nums,j,cop,size,ans);
    }
}
```

时间复杂度都是(O(2^n * n) 因为最坏情况每个数都不同，都要展开，然后到达每个叶子结点需要生成一个List

测试链接:https://leetcode.cn/problems/subsets-ii/description/

## 3.数组全排列

这道题左神提供了一个全新的思路，当来到一个位置，让后面所有人到来坐这个位置,直到所有人都坐满收集答案。

代码如下:

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> ans=new ArrayList<>();
    f(nums,0,ans);
    return ans;
}
public void f(int[] nums,int index,List<List<Integer>> ans) {
    if(index==nums.length) {
        List<Integer> list=new ArrayList<>();
        for(int num:nums) list.add(num);
        ans.add(list);
    }
    //让所有人都来坐当前位置
    for(int i=index;i<nums.length;i++) {
        swap(nums,index,i);
        f(nums,index+1,ans);
        swap(nums,index,i);//恢复现场
    }
}
public static void swap(int[] nums,int index1,int index2) {
    if(index1==index2) return;
    nums[index1]=nums[index1]^nums[index2];
    nums[index2]=nums[index1]^nums[index2];
    nums[index1]=nums[index1]^nums[index2];
}
```

对于为何要恢复现场:

我画了一个图:

![合问题递归](.\assets\组合问题递归图.png)

对于这颗递归树而言，因为我们写代码是在每一层执行的，如果不恢复，当前递归层的父节点就会受到上一个分支的叶节点影响，从而答案错误。

测试链接:https://leetcode.cn/problems/permutations/

时间复杂度O(n! * n) 递归调用+收集答案

## 4.数组全排列，有重复元素

这道题思路和题目3一样，只不过在交换的时候，如果这个数在交换之前就已经出现了，那么这个数就不需要交换，感觉这个想法还是很妙。

为啥前面有这个数，当前数就不交换，因为前面已经把这个数的每一种可能都算了，当前数再算就是重复。

代码:

```java
public List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> ans=new ArrayList<>();
    f(nums,0,ans);
    return ans;
}
public void f(int[] nums,int index,List<List<Integer>> ans) {
    if(index == nums.length) {
        List<Integer> list=new ArrayList<>();
        for(int num:nums) {
            list.add(num);
        }
        ans.add(list);
    }

    Set<Integer> set= new HashSet<>();
    for(int i=index;i<nums.length;i++) {
        if(!set.contains(nums[i])) {
            set.add(nums[i]);
            swap(nums,index,i);
            f(nums,index+1,ans);
            swap(nums,index,i);
        }
    }

}
public static void swap(int[] nums,int i,int j) {
    if(i==j)return;
    nums[i]=nums[i]^nums[j];
    nums[j]=nums[i]^nums[j];
    nums[i]=nums[i]^nums[j];
}
```

时间复杂度O(n! * n) 最坏情况下每个数都不相同和题目三的复杂度相同

测试链接:https://leetcode.cn/problems/permutations-ii/

## 5.用递归逆序一个栈

在这个算法之前，先熟悉一下Java中的栈

java中栈有Stack(传统类)和Deque(双端队列)，Stack的性能不如Deque

基于性能优先选择Deque，Deque的实现类主要有ArrayDeque和LinkedList

Deque常用的方法

| 方法      | 功能                                     |
| --------- | ---------------------------------------- |
| push(e)   | 入栈，等价于addFirst(e)                  |
| pop()     | 出栈，等价于removeFirst()，空时抛异常    |
| peek()    | 查看栈顶，等价于peekFirst(),空时返回null |
| isEmpty() | 是否为空                                 |

左神说理解并掌握了这个代码会让人递归有质的飞跃，我尝试用图解和代码写了一下

reverseStack递归图解:

![evers](assets\reverse.png)

bottomOut递归图解:

![ottomOu](assets\bottomOut.png)

代码:

```java
public static void main(String[] args) {
    Deque<Integer> deque=new ArrayDeque<>();
    deque.push(1);
    deque.push(2);
    deque.push(3);
    System.out.println(deque);//[3, 2, 1]
    reverseStack(deque);
    System.out.println(deque);//[1, 2, 3]
}

public static void reverseStack(Deque<Integer> stack) {
    if(stack.isEmpty()) {
        return;
    }
    Integer bottom= bottomOut(stack);//获取栈低的元素并返回
    reverseStack(stack);
    stack.push(bottom);
}

//移除并返回返回
public static Integer bottomOut(Deque<Integer> stack) {
    Integer top=stack.pop();
    if(stack.isEmpty()) {
        return top;
    }

    int nextBottom=bottomOut(stack);
    stack.push(top);
    return nextBottom;

}
```

心得:写递归感觉有点像AOP的感觉，递归之前什么操作，递归之后什么操作，什么时候调用递归，画出递归图解感觉就会好想很多~

时间复杂度:O(n^2)

## 6.用递归排序一个栈

这道题用了4个递归函数,大的流程如下:

```java
public static void sort(Deque<Integer> stack) {
    int deep=getDeepOfStack(stack);//获取元素个数
    while(deep>0) {
        int max=getMaxIntOfStack(stack,deep);//deep的深度的最大值
        int times=getMaxTimes(stack,max,deep);//最大值有几个
        goDown(stack,max,times,deep);//将这几个最大值沉底
        deep-=times;
    }
}
```

4个递归函数

```java
public static int getDeepOfStack(Deque<Integer> stack) {
    if(stack.isEmpty()) return 0;
    int top=stack.pop();
    int deep=getDeepOfStack(stack)+1;
    stack.push(top);
    return deep;
}
public static int getMaxIntOfStack(Deque<Integer> stack,int deep) {
    if(deep==1) {
        return stack.peek();
    }
    int top=stack.pop();
    int ans=Math.max(getMaxIntOfStack(stack,deep-1), top);
    stack.push(top);
    return ans;
}
public static int getMaxTimes(Deque<Integer> stack,int max,int deep) {
    if(deep==0) {
        return 0;
    }
    int top=stack.pop();
    int ans=getMaxTimes(stack,max,deep-1)+(top==max?1:0);
    stack.push(top);
    return ans;
}
public static void goDown(Deque<Integer> stack,int max,int times,int deep) {
    if(deep==0) {
        for(int i=0;i<times;i++) {
            stack.push(max);
        }
        return;
    }
    int top=stack.pop();
    goDown(stack,max,times,deep-1);
    if(top!=max) stack.push(top);
}
```

时间复杂度O(n^2)

总结了一下这些递归，形成了一下模板

```java
public void f(参数){
    if(到达终止条件){
        ...
        return;
    }
    //记录当前数据
    f(参数)//下一层递归
    //恢复数据
}
```

## 7.汉诺塔问题

这个问题自己之前会了，听完左神讲，这个就是一个抽象的递归，思考其细节反而不容易想到

```java
public void HanNuo(int n,String from,String to,String other) {
    if(n==1) {
        System.out.println(n+from+"->"+to);
        return;
    }
    HanNuo(n-1,from,other,to);
    System.out.println(n+from+"->"+to);
    HanNuo(n-1,other,to,from);
}
```

n层汉诺塔移动步数(2^n-1)

f(n)=2f(n-1)+1

f(1)=1

s(n)=(2^n-1)

所以时间复杂度O(2^n)









