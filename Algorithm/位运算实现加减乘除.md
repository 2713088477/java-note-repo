# 位运算实现加减乘除

## 1.加法

加法的核心就在于n1+n2

n1^n2得到无进位的结果

(n1&n2)<<1得到有进位的结果

将这两者相加，不断循环，直到进位的结果为0

```java
public static int plus(int n1,int n2) {
    int ans=0;
    while(n2!=0) {
    	ans=n1^n2;
    	n2=(n1&n2)<<1;
    	n1=ans;
    }
    return ans;
}
```



## 2.减法

减去一个数等于加上这个数的相反数，注意取相反数的时候不要有整数最小值

```java
//整数最小值会失效
public static int reverse(int n) {
    return plus(~n,+1);
}
public static int minus(int n1,int n2) {
    return plus(n1,reverse(n2));
}
```

## 3.乘法

乘法就在于n1*n2的时候，只要n2的二进制位有一个不为0，就会对结果造成影响。

比如1101x1111

1101x0001=1101

1101x0010=11010

1101x0100=110100

1101x1000=1101000

最后将这些结果相加

详情请看代码:

```java
//这个乘法如果n2<0,就有问题
public static int multiply(int n1,int n2) {
    int ans=0;
    while(n2!=0) {
        if((n2&1)==1) {
        	ans=plus(ans,n1);
    	}
        n1=n1<<1;
        n2=n2>>>1;
    }
    return ans;
}
```

## 4.除法

这个除法是最妙的,简而言之其思想就是n1=n2xPow(2,i),所以从最高位开始，只要n1左移i位>=n2，就说明在这一位是1，减掉之后，如此反复。

```java
//利用到了reverse,所以整数最小值会失效
public static int divide(int n1,int n2) {
    int x=n1<0?reverse(n1):n1;
    int y=n2<0?reverse(n2):n2;
    int ans=0;
    for(int i=30;i>=0;i--) {
        if((x>>i)>=y) {
            ans|=(1<<i);
            x= minus(x,(y<<i));
        }
    }
    return n1<0 ^ n2<0?reverse(ans):ans;
}
//分类讨论Integer.MIN_VALUE
public static int dividePlus(int n1,int n2) {
    int MIN=Integer.MIN_VALUE;
    if(n1==MIN&&n2==MIN) {
        return 1;
    }
    if(n1==MIN) {
        if(n2==1) return MIN;
        else if(n2==-1) return Integer.MAX_VALUE;//leetcode29上说的;
        else {
            n1=plus(n1,n2<0?reverse(n2):n2);
            int ans=divide(n1,n2);
            ans=plus(ans,n2<0?1:reverse(1));
            return ans;
        }
    }
    if(n2==MIN) {
        return 0;
    }
    return divide(n1,n2);
}
```

测试链接:https://leetcode.cn/problems/divide-two-integers/description/







