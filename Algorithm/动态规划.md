# 动态规划

## 1.编辑距离

给你两个单词 `word1` 和 `word2`， 请返回将 word1 转换成 word2 的最小代价。

可以对s1的每个字符可以进行插入insert，删除delete，修改update的操作。

代码:

```java
class Main{
    private int insert;
    private int delete;
    private int replace;

    //将word1变为word2的最小代价
    public int minDistance1(String word1, String word2) {
        insert=1;
        delete=1;
        replace=1;
        char[] s1=word1.toCharArray();
        char[] s2=word2.toCharArray();
        return f1(s1,s2,s1.length,s2.length);
    }
    //暴力递归
    //将s1[0...len1-1]变为s2[0...len2-1]的最小代价
    public int f1(char[] s1,char[] s2,int len1,int len2){
        if(len1==0 && len2==0) return 0;
        if(len1==0) return insert*len2;
        if(len2==0) return delete*len1;

        if(s1[len1-1]==s2[len2-1]){
            return f(s1,s2,len1-1,len2-1);
        }else{
            //将当前位置替换成s2[len2-1]
            int ans1=f(s1,s2,len1-1,len2-1)+replace;
            int ans2=f(s1,s2,len1-1,len2-1)+delete+insert;

            //不要当前位置
            int ans3=f(s1,s2,len1-1,len2)+delete;

            //保留当前位置
            int ans4=f(s1,s2,len1,len2-1)+insert;
            
            return Math.min(Math.min(ans1,ans2),Math.min(ans3,ans4));
        }
    }

    //将word1变为word2的最小代价
    public int minDistance2(String word1, String word2) {
        insert=1;
        delete=1;
        replace=1;
        char[] s1=word1.toCharArray();
        char[] s2=word2.toCharArray();
        return f2(s1,s2);
    }
    //动态规划
    public int f2(char[] s1,char[] s2){
        int len1=s1.length;
        int len2=s2.length;
        int[][] dp=new int[len1+1][len2+1];
        for(int i=1;i<=len1;i++){
            dp[i][0]=i*delete;
        }
        for(int i=1;i<=len2;i++){
            dp[0][i]=i*insert;
        }
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(s1[i-1]==s2[j-1]){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    int ans1=dp[i-1][j-1]+replace;
                    int ans2=dp[i-1][j-1]+delete+insert;
                    int ans3=dp[i-1][j]+delete;
                    int ans4=dp[i][j-1]+insert;
                    dp[i][j]=Math.min(Math.min(ans1,ans2),Math.min(ans3,ans4));
                }
            }
        }
        return dp[len1][len2];
    }


    //将word1变为word2的最小代价
    public int minDistance3(String word1, String word2) {
        insert=1;
        delete=1;
        replace=1;
        char[] s1=word1.toCharArray();
        char[] s2=word2.toCharArray();
        return f3(s1,s2);
    }
    //动态规划+空间压缩
    public int f3(char[] s1,char[] s2){
        int len1=s1.length;
        int len2=s2.length;
        int[] dp=new int[len2+1];
        for(int i=1;i<=len2;i++){
            dp[i]=i*insert;
        }
        for(int i=1,leftUp,temp;i<=len1;i++){
            leftUp=dp[0];
            dp[0]=i*delete;
            for(int j=1;j<=len2;j++){
                temp=dp[j];
                if(s1[i-1]==s2[j-1]){
                    dp[j]=leftUp;
                }else{
                    int ans1=leftUp+replace;
                    int ans2=leftUp+delete+insert;
                    int ans3=dp[j-1]+delete;
                    int ans4=dp[j]+insert;
                    dp[j]=Math.min(Math.min(ans1,ans2),Math.min(ans3,ans4));
                }
                leftUp=temp;
            }
        }
        return dp[len2];
    }
}

```

