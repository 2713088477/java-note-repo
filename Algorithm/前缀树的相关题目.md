# 前缀树的相关题目

## 1.接头密钥

 牛牛和他的朋友们约定了一套接头密匙系统，用于确认彼此身份
 密匙由一组数字序列表示，两个密匙被认为是一致的，如果满足以下条件：
 密匙 b 的长度不超过密匙 a 的长度。
 对于任意 0 <= i < length(b)，有b[i+1] - b[i] == a[i+1] - a[i]
 现在给定了m个密匙 b 的数组，以及n个密匙 a 的数组
 请你返回一个长度为 m 的结果数组 ans，表示每个密匙b都有多少一致的密匙
 数组 a 和数组 b 中的元素个数均不超过 10^5
 1 <= m, n <= 1000
 测试链接 : https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932

代码:

```java
//测试链接:https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932
public class Code01_Solution {
    public static int MAX_SIZE = 100005;
    public static int[][] node = new int[MAX_SIZE][12];
    public static int[] pass = new int[MAX_SIZE];
    public static int cnt;
    public static void build(){
        cnt = 1;
    }
    public static void clear(){
        for(int i=1;i<=cnt;i++){
            Arrays.fill(node[i],0);
            pass[i]=0;
        }
    }
    public static int calPath(char c){
        if(c=='-') return 10;
        else if(c=='#') return 11;
        else return c-'0';
    }
    public static void insert(String word){
        int cur =1;
        pass[cur]++;
        int path;
        for(int i=0;i<word.length();i++){
            path = calPath(word.charAt(i));
            if(node[cur][path]==0){
                node[cur][path]=++cnt;
            }
            cur = node[cur][path];
            pass[cur]++;
        }
    }
    public static int startWith(String prefix){
        int cur =1;
        int path;
        for(int i=0;i<prefix.length();i++){
            path = calPath(prefix.charAt(i));
            if(node[cur][path]==0) return 0;
            cur = node[cur][path];
        }
        return pass[cur];
    }

    public int[] countConsistentKeys (int[][] b, int[][] a) {
        //将a所有的前缀加入前缀树中
        build();
        StringBuilder builder = new StringBuilder();
        for(int i=0;i<a.length;i++){
            builder.setLength(0);
            for(int j=1;j<a[i].length;j++){
                builder.append(String.valueOf(a[i][j]-a[i][j-1])+"#");

            }
            //插入到前缀树中
            insert(builder.toString());

        }
        //统计结果
        int[] ans = new int[b.length];
        for(int i=0;i<b.length;i++){
            builder.setLength(0);
            for(int j=1;j<b[i].length;j++){
                builder.append(String.valueOf(b[i][j]-b[i][j-1])+"#");

            }
            // 查询builder在前缀树中出现了几次
            ans[i] = startWith(builder.toString());
        }
        clear();
        return ans;
    }
}
```

这道题思路很清楚，就是利用**前缀树**

但是区别就是,存进去的数字可能**很大**，比如**10000**,我们没有必要构建一个10000叉的树

因此我们是这样存的，比如"123 31 -32" -> "123#31#-32"

我们利用"#"区分每一对数字，然后还有可能为负数"-",所以我们存储12叉树(0-9,'#','-')

**时间复杂度:O(a数组的数字个数*10)+O(b数组的数字个数 *10)**

**空间复杂度:O(a数组的数字个数*10),这是树上的节点数量**

## 2.数组中两个数异或最大值

这道题题意很简单，就是返回数组中两个数异或的最大值

**前缀树的做法:**

```java
import java.util.Arrays;
//测试链接:https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/
public class Code02_Solution {

    public static int high;
    public static int MAX_SIZE = 1000000;
    public static int[][] node = new int[MAX_SIZE][2];
    public static int cnt;
    public static void build(){
        cnt=1;
    }
    public static void clear(){
        for(int i=1;i<=cnt;i++){
            Arrays.fill(node[i],0);
        }
    }
    public static void insert(int num){
        int cur = 1;
        for(int i=high-1;i>=0;i--){
            int path = (num>>i) & 1;
            if(node[cur][path]==0){
                node[cur][path]=++cnt;
            }
            cur = node[cur][path];
        }
    }
    public static int solve(int num){
        int ans = 0;
        int cur =1;
        for(int i=high-1;i>=0;i--){
            int status = (num>>i) & 1;
            int want = status ^ 1;
            if(node[cur][want]==0){
                want ^=1;
            }
            ans |= (want^status)<<i;
            cur = node[cur][want];
        }
        return ans;
    }
    public int findMaximumXOR(int[] nums) {
        int value = Integer.MIN_VALUE;
        for (int num : nums) {
            value = Math.max(num,value);
        }
        high = 32-Integer.numberOfLeadingZeros(value);
        build();
        for (int num : nums) {
            //将每个数字加入到前缀树中
            insert(num);
        }
        int ans = 0;
        for (int num : nums) {
            //处理每个数字
            ans = Math.max(ans,solve(num));
        }
        clear();
        return ans;
    }

}
```

这道题的做法:

就是将每个数加入到前缀树中，然后再去处理每个数，然后每个数从最高位开始找能使其称为1的，遍历完整个数组看看最大值。

**哈希表的做法:**

```java
import java.util.HashSet;
import java.util.Set;
//测试链接:https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/
public class Code03_Solution {
    public static int high;
    public int findMaximumXOR(int[] nums) {
        int val = Integer.MIN_VALUE;
        for(int num:nums){
            val = Math.max(val,num);
        }
        high = 31 - Integer.numberOfLeadingZeros(val);
        int ans =0;
        Set<Integer> set = new HashSet<>();
        for(int i=high;i>=0;i--){
            int better = ans | (1<<i);
            set.clear();
            for (int num : nums) {
                num = (num>>i)<<i;
                set.add(num);
                //num^x=better -> x=better^num
                if(set.contains(better^num)){
                    ans = better;
                    break;
                }
            }
        }
        return ans;
    }
}
```

哈希表的做法整体思路和前缀树差不多，但是哈希表的做法更难想，实现起来需要更多的思考和编码能力

主要有两个点比较难:

1.(num>>i)<<i :将后面i位的数字全部刷成0

2.num^x=better -> x=better^num



前缀树做法和哈希表的做法

时间复杂度O(n*log(v)),空间复杂度O(n*log(v)) ,v是数值范围

## 3.单词搜索

这道题与普通的单词搜索不同，主要就是要搜索的单词不是一个，而是一个数组

```java
import java.util.*;

//leetcode链接:https://leetcode.cn/problems/word-search-ii/submissions/698656777/
public class Code05_Solution {
    public char[][] board;
    public List<String> findWords(char[][] board, String[] words) {
        build();
        for (String word : words) {
            insert(word);
        }
        this.board = board;
        List<String> list = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                f(i,j,1,list);
            }
        }
        clear();
        return list;
    }
    public static int[][] dw = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};
    public int f(int x, int y, int cur, List<String> list) {
        if(x<0 || x>=board.length || y<0 || y>=board[0].length || board[x][y]==0){
            return 0;
        }
        int path = board[x][y]-'a';
        if(node[cur][path]==0) return 0;
        cur=node[cur][path];
        int fix = 0;
        if(end[cur]!=null){
            list.add(end[cur]);
            fix++;
            end[cur]=null;
        }
        char c = board[x][y];
        board[x][y]=0;
        for(int i=0;i<dw.length;i++){
            int nx = x+dw[i][0];
            int ny = y+dw[i][1];
            fix += f(nx,ny,cur,list);
        }
        board[x][y]=c;
        pass[cur] -= fix;
        return fix;
    }

    public static int MAX_SIZE = 300000;
    public static int[][] node = new int[MAX_SIZE][26];
    public static int[] pass = new int[MAX_SIZE];
    public static String[] end = new String[MAX_SIZE];
    public static int cnt;
    public static void build(){
        cnt=1;
    }
    public static void insert(String word){
        int cur = 1;
        pass[cur]++;
        for(int i=0;i<word.length();i++){
            int path = word.charAt(i)-'a';
            if(node[cur][path]==0){
                node[cur][path]=++cnt;
            }
            cur = node[cur][path];
            pass[cur]++;
        }
        end[cur]=word;
    }
    public static void clear(){
        for(int i=1;i<=cnt;i++){
            Arrays.fill(node[i],0);
            end[i]=null;
            pass[i]=0;
        }
    }
}
```

这是左神的写法，主要有三层剪枝:

1.搜过的地方标记board为0，避免重复搜索

2.找到了就把end[cur]置为空，然后每次找到了都会删除掉，这个点找到了几条路，就会删除掉几个pass信息

3.利用前缀树高效搜索



时间复杂度，O(m * n * 4^10)
不管用不用前缀树都是这个复杂度，只不过前缀树可以大量剪枝，优化常数时间
空间复杂度，O(words中所有字符串的全部字符数量)


