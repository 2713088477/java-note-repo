# 前缀树的相关题目

## 1.接头密钥

 牛牛和他的朋友们约定了一套接头密匙系统，用于确认彼此身份
 密匙由一组数字序列表示，两个密匙被认为是一致的，如果满足以下条件：
 密匙 b 的长度不超过密匙 a 的长度。
 对于任意 0 <= i < length(b)，有b[i+1] - b[i] == a[i+1] - a[i]
 现在给定了m个密匙 b 的数组，以及n个密匙 a 的数组
 请你返回一个长度为 m 的结果数组 ans，表示每个密匙b都有多少一致的密匙
 数组 a 和数组 b 中的元素个数均不超过 10^5
 1 <= m, n <= 1000
 测试链接 : https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932

代码:

```java
//测试链接:https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932
public class Code01_Solution {
    public static int MAX_SIZE = 100005;
    public static int[][] node = new int[MAX_SIZE][12];
    public static int[] pass = new int[MAX_SIZE];
    public static int cnt;
    public static void build(){
        cnt = 1;
    }
    public static void clear(){
        for(int i=1;i<=cnt;i++){
            Arrays.fill(node[i],0);
            pass[i]=0;
        }
    }
    public static int calPath(char c){
        if(c=='-') return 10;
        else if(c=='#') return 11;
        else return c-'0';
    }
    public static void insert(String word){
        int cur =1;
        pass[cur]++;
        int path;
        for(int i=0;i<word.length();i++){
            path = calPath(word.charAt(i));
            if(node[cur][path]==0){
                node[cur][path]=++cnt;
            }
            cur = node[cur][path];
            pass[cur]++;
        }
    }
    public static int startWith(String prefix){
        int cur =1;
        int path;
        for(int i=0;i<prefix.length();i++){
            path = calPath(prefix.charAt(i));
            if(node[cur][path]==0) return 0;
            cur = node[cur][path];
        }
        return pass[cur];
    }

    public int[] countConsistentKeys (int[][] b, int[][] a) {
        //将a所有的前缀加入前缀树中
        build();
        StringBuilder builder = new StringBuilder();
        for(int i=0;i<a.length;i++){
            builder.setLength(0);
            for(int j=1;j<a[i].length;j++){
                builder.append(String.valueOf(a[i][j]-a[i][j-1])+"#");

            }
            //插入到前缀树中
            insert(builder.toString());

        }
        //统计结果
        int[] ans = new int[b.length];
        for(int i=0;i<b.length;i++){
            builder.setLength(0);
            for(int j=1;j<b[i].length;j++){
                builder.append(String.valueOf(b[i][j]-b[i][j-1])+"#");

            }
            // 查询builder在前缀树中出现了几次
            ans[i] = startWith(builder.toString());
        }
        clear();
        return ans;
    }
}
```

这道题思路很清楚，就是利用**前缀树**

但是区别就是,存进去的数字可能**很大**，比如**10000**,我们没有必要构建一个10000叉的树

因此我们是这样存的，比如"123 31 -32" -> "123#31#-32"

我们利用"#"区分每一对数字，然后还有可能为负数"-",所以我们存储12叉树(0-9,'#','-')

**时间复杂度:O(a数组的数字个数*10)+O(b数组的数字个数 *10)**

**空间复杂度:O(a数组的数字个数*10),这是书上的节点数量**


