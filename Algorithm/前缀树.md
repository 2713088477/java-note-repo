# 前缀树

## 1.基本概念

前缀树又叫字典树，英文名trie

每个样本都从头节点开始，根据前缀字符或者前缀数字建出来的一棵大树，这就是前缀树

<font color="red">没有路就新建节点;已经有路了，就复用节点</font>

**前缀树的使用场景:** 需要根据前缀信息来查询的场景

**前缀树的优点:** 根据前缀信息选择树上的分支，可以节省大量的时间

**前缀树的缺点:** 比较浪费空间，和总字符数量有关，字符的种类有关

**前缀树的定制:** pass,end等信息

## 2.类描述实现

```java
public class Code01_TrieTree {
    static class Trie1{
        class TrieNode{
            int pass;
            int end;
            TrieNode[] next = new TrieNode[26];
        }
        private TrieNode root;
        /** Initialize your data structure here. */
        public Trie1() {
            root = new TrieNode();
        }
        /** Inserts a word into the trie. */
        public void insert(String word) {
            char[] array = word.toCharArray();
            TrieNode node = root;
            node.pass++;
            for (char c : array) {
                int index = c-'a';
                if(node.next[index]==null){
                    node.next[index] = new TrieNode();
                }
                node = node.next[index];
                node.pass++;
            }
            node.end++;
        }

        /** delete the word in the trie*/
        public void delete(String word){
            char[] array = word.toCharArray();
            TrieNode node = root;
            root.pass--;
            for (char c : array) {
                int index = c-'a';
                //这个方法我实现的时候，必须要确保word存在于前缀树中
                node = node.next[index];
                node.pass--;
            }
            node.end--;
        }

        /** Returns if the word is in the trie. */
        public boolean search(String word) {
            char[] array = word.toCharArray();
            TrieNode node = root;
            for (char c : array) {
                int index = c-'a';
                if(node.next[index]==null) return false;
                node = node.next[index];
            }
            return node.end >0;
        }

        /** Returns if there is any word in the trie that starts with the given prefix. */
        public int startsWith(String prefix) {
            char[] array = prefix.toCharArray();
            TrieNode node = root;
            for (char c : array) {
                int index = c-'a';
                if(node.next[index]==null) return 0;
                node = node.next[index];
            }
            return node.pass;
        }
    }
}
```

**这种写法一般不推荐，因为要动态创建空间**

<font color="red">基础实现的时候，一般给节点添加pass和end信息</font>

<font color="red">如果每个节点的子节点非常多，我们可以再做优化，比如"abc#cd#dc#",增加一个结束的标志</font>

## 3.静态空间实现

```java
public class Code02_TrieTree {
    public static int MAX_Size = 1000000;
    public static int[][] node = new int[MAX_Size][26];
    public static int[] pass = new int[MAX_Size];
    public static int[] end = new int[MAX_Size];
    public static int cnt;
    public static void build(){
        cnt = 1;
    }
    public static void clear(){
        Arrays.fill(pass,1,cnt+1,0);
        Arrays.fill(end,1,cnt+1,0);
        for(int i=1;i<=cnt;i++){
            Arrays.fill(node[i],0);
        }
    }
    public static void insert(String word){
        char[] array = word.toCharArray();
        int cur = 1;
        pass[cur]++;
        for(char c:array){
            int index=c-'a';
            if(node[cur][index]==0){
                node[cur][index]=++cnt;
            }
            cur = node[cur][index];
            pass[cur]++;
        }
        end[cur]++;
    }
    public static void delete(String word){
        char[] array = word.toCharArray();
        int cur = 1;
        pass[cur]--;
        for(char c:array){
            int index=c-'a';
            if((--pass[node[cur][index]]) == 0){
                node[cur][index]=0;
                return;
            }
            cur = node[cur][index];
        }
        end[cur]--;
    }
    public static boolean search(String word){
        char[] array = word.toCharArray();
        int cur = 1;
        if(pass[cur]<=0) return false;
        for(char c:array){
            int index=c-'a';
            if(node[cur][index]==0){
                return false;
            }
            cur = node[cur][index];
            if(pass[cur]<=0) return false;
        }
        return end[cur]>0;
    }
    public static int prefixNumber(String pre){
        char[] array = pre.toCharArray();
        int cur = 1;
        if(pass[cur]<=0) return 0;
        for(char c:array){
            int index=c-'a';
            if(node[cur][index]==0){
                return 0;
            }
            cur = node[cur][index];
            if(pass[cur]<=0) return 0;
        }
        return pass[cur];
    }

    public static String line;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        build();
        int tNum = Integer.valueOf(br.readLine());
        while(tNum-- > 0){
            line=br.readLine();
            String[] split = line.split(" ");
            switch(split[0]){
                case("1"):
                    insert(split[1]);
                    break;
                case("2"):
                    delete(split[1]);
                    break;
                case("3"):
                    out.println(search(split[1])==true?"YES":"NO");
                    break;
                case("4"):
                    out.println(prefixNumber(split[1]));
                    break;
            }
        }
        clear();
        out.flush();
        out.close();
        br.close();
    }
}
```

**这是常用写法，但是要注意MAX_SIZE一定要合理，不能太小也不能太大**
