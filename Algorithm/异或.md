# 异或运算

## 异或核心

### 1.如何理解异或?

有两种理解，推荐理解第一种

第一种:无进位相加

第二种:相同为0，不同为1

### 2.异或运算性质

异或满足交换律和结合律，只要是同一批数，不管异或的顺序如何，结果总是相同的

### 3.异或重要结论

0 ^ n =n

n ^ n =0

 ### 4.奇淫技巧

整体异或的结果如果是X,如果部分异或的结果是Y,那么剩余部分异或的结果是X ^ Y

## 异或有关的题

### 1.交换两个数

```java
public static void main(String[] args) {
    int a=10,b=-10;
    a=a^b;
    b=a^b;
    a=a^b;
    System.out.println(a+" "+b); //-10 10
}
```

但是这个算法有缺陷,a和b必须是不同的地址，不然会出错

```java
public static void main(String[] args) {
    int[] arr=new int[]{10,9,8,7,6,5};
    swap(arr,0,1);
    System.out.println(Arrays.toString(arr));  //[9, 10, 8, 7, 6, 5]
    swap(arr,0,0);
    System.out.println(Arrays.toString(arr));  //[0, 10, 8, 7, 6, 5] 出错了
}
public static void swap(int[] arr,int i,int j) {
    arr[i]=arr[i]^arr[j];
    arr[j]=arr[i]^arr[j];
    arr[i]=arr[i]^arr[j];
}
```

所以最好的做法是特判一下

```java
public static void swap(int[] arr,int i,int j) {
    if(i==j) return;
    arr[i]=arr[i]^arr[j];
    arr[j]=arr[i]^arr[j];
    arr[i]=arr[i]^arr[j];
}
```

### 2.不用任何判断语句和比较操作，返回两个数的最大值

```java
// 必须保证n一定是0或者1
// 0变1，1变0
public static int flip(int n) {
    return n ^ 1;
}

// 非负数返回1
// 负数返回0
public static int sign(int n) {
    return flip(n >>> 31);
}

// 有溢出风险的实现
public static int getMax1(int a, int b) {
    int c = a - b;
    // c非负，returnA -> 1
    // c非负，returnB -> 0
    // c负数，returnA -> 0
    // c负数，returnB -> 1
    int returnA = sign(c);
    int returnB = flip(returnA);
    return a * returnA + b * returnB;
}

// 没有任何问题的实现
public static int getMax2(int a, int b) {
    // c可能是溢出的
    int c = a - b;
    // a的符号
    int sa = sign(a);
    // b的符号
    int sb = sign(b);
    // c的符号
    int sc = sign(c);
    // 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0
    int diffAB = sa ^ sb;
    // 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0
    int sameAB = flip(diffAB);
    //返回A的条件 (ab<0 & a>0) || (ab>0 & c>0)
    int returnA = diffAB * sa + sameAB * sc;
    int returnB = flip(returnA);
    return a * returnA + b * returnB;
}

public static void main(String[] args) {
    int a = Integer.MIN_VALUE;
    int b = Integer.MAX_VALUE;
    // getMax1方法会错误，因为溢出
    System.out.println(getMax1(a, b));
    // getMax2方法永远正确s
    System.out.println(getMax2(a, b));
}
```

### 3.丢失的数字

力扣链接:[268. 丢失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number/description/)

```java
public int missingNumber(int[] nums) {
    int hasXor=0,ansXor=0;
    for(int i=0;i<nums.length;i++){
    ansXor^=i;
    hasXor^=(nums[i]);
    }
    ansXor^=nums.length;
    return hasXor^ansXor;
}
```

### 4.数组中一种数出现了奇数次，其余数都出现了偶数次，返回出现了奇数次的数

```java
public int singleNumber(int[] nums) {
    int ans=0;
    for(int num:nums){
    ans^=num;
    }
    return ans;
}
```

力扣链接:[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/)

说明:力扣的和题目说明略有不同，但是这个代码都可以满足

### 5.Brian Kernighan算法 

这个算法说的是，一个二进制串，比如1010，我们需要返回0010，即保留最右边的1，其余位置全为0

操作方法: n&(~n+1)   换一种表达 n&(-n)

### 6.数组中有两种数出现了奇数次，其余数出现了偶数次，找出这两个出现奇数次的数

核心思想:将这两个出现奇数次的数分开，即将数组分为两堆，这两个出现奇数次的数分别在这两堆中的一堆，然后逐个击破

```java
public int[] singleNumber(int[] nums) {
    int xorTotal=0;
    for(int num:nums) {
    	xorTotal ^= num;
    }
    //整体异或后,xorTotal肯定是两个出现奇数次的数贡献的
    //最右侧的1，说明在这个二进制位，两个出现奇数次的数一定不同
    int rightBit=xorTotal&(~xorTotal+1);
    //根据这个将两个数区分出来
    int xor1=0,xor2=0;
    for(int num:nums) {
    if((num&rightBit)==0) {
    	xor1 ^= num;
    }else {
    	xor2 ^= num;
    }
    }
    return new int[] {xor1,xor2};
}
```

测试链接:[260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/description/)

说明:力扣的和题目说明略有不同，但是这个代码都可以满足

### 7.数组中只有1种数出现次数少于m次，其他数都出现了m次，返回出现次数小于m次的那种数

核心思想:看每个二进制位的1出现了多少次,然后某个二进制位出现1的次数%m!=0,说明这个二进制位肯定有少于m次出现的数的贡献

```java
public int lessMNumber(int[] nums,int m) {
    int[] cnt=new int[32];
    for(int num:nums) {
        for(int i=0;i<32;i++) {
            if((num&(1<<i))!=0) {
                cnt[i]++;
            }
        }
    }
    int ans=0;
    for(int i=0;i<32;i++) {
        if(cnt[i]%m!=0) {
            ans= ans | (1<<i);
        }
    }
    return ans;
}
```

测试链接:[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/)

说明:力扣的和题目说明略有不同，但是这个代码都可以满足