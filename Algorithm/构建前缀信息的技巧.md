# 构建前缀信息的技巧-解决子数组相关问题

**解决如下问题，时间复杂度O(n)**

## 题目一

构建前缀和数组。快速解决子数组范围求和的问题

```java
//测试链接:https://leetcode.cn/problems/range-sum-query-immutable/description/
class NumArray {
    //sum[i]表示前i的数字的前缀和
    //这样设计避免了求[0,1]时候要重新写判断语句
    public int[] sum;

    public NumArray(int[] nums) {
        int len=nums.length;
        sum = new int[len+1];
        for(int i=1;i<=len;i++){
            sum[i]=sum[i-1]+nums[i-1];
        }
    }

    public int sumRange(int left, int right) {
        return sum[right+1]-sum[left];
    }
}
```

## 题目二

构建前缀和最早出现的位置。返回无序数组中累加和为给定值的最长子数组长度。

```java
import java.io.*;
import java.util.Map;
import java.util.HashMap;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while(in.nextToken() != StreamTokenizer.TT_EOF){
            int n = (int)in.nval;in.nextToken();
            int k = (int)in.nval;in.nextToken();
            int[] arr= new int[n];
            for(int i=0;i<n;i++){
                arr[i]=(int)in.nval;
                in.nextToken();
            }
            out.println(f(arr,k));
        }
        out.flush();
        out.close();
        br.close();
    }
    public static int f(int[] arr,int k){
        int ans = Integer.MIN_VALUE;
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        for(int i=0,sum=0;i<arr.length;i++){
            sum += arr[i];
            //sum-need=k;
            if(map.containsKey(sum-k)){
                ans=Math.max(ans,i-map.get(sum-k));
            }
            if(!map.containsKey(sum)){
                map.put(sum,i);
            }
        }
        return ans;
    }
}
```

这道题的核心思路就是:

记录每一个前缀最早出现的位置，<font color="red">但是最开始要存一个map,set(0,-1),0最早出现的位置是-1</font>

然后去遍历元素，sum记录从0到当前元素的求和值，sum-need=k,只要need存在就更新一次答案，最后返回答案


