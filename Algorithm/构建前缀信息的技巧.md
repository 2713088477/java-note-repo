# 构建前缀信息的技巧-解决子数组相关问题

**解决如下问题，时间复杂度O(n)**

<font color="red">提示:子数组一定是连续的</font>

## 题目一

构建前缀和数组。快速解决子数组范围求和的问题

```java
//测试链接:https://leetcode.cn/problems/range-sum-query-immutable/description/
class NumArray {
    //sum[i]表示前i的数字的前缀和
    //这样设计避免了求[0,1]时候要重新写判断语句
    public int[] sum;

    public NumArray(int[] nums) {
        int len=nums.length;
        sum = new int[len+1];
        for(int i=1;i<=len;i++){
            sum[i]=sum[i-1]+nums[i-1];
        }
    }

    public int sumRange(int left, int right) {
        return sum[right+1]-sum[left];
    }
}
```

## 题目二

构建前缀和最早出现的位置。返回无序数组中累加和为给定值的最长子数组长度。

```java
import java.io.*;
import java.util.Map;
import java.util.HashMap;
// 测试链接 : https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while(in.nextToken() != StreamTokenizer.TT_EOF){
            int n = (int)in.nval;in.nextToken();
            int k = (int)in.nval;in.nextToken();
            int[] arr= new int[n];
            for(int i=0;i<n;i++){
                arr[i]=(int)in.nval;
                in.nextToken();
            }
            out.println(f(arr,k));
        }
        out.flush();
        out.close();
        br.close();
    }
    public static int f(int[] arr,int k){
        int ans = Integer.MIN_VALUE;
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        for(int i=0,sum=0;i<arr.length;i++){
            sum += arr[i];
            //sum-need=k;
            if(map.containsKey(sum-k)){
                ans=Math.max(ans,i-map.get(sum-k));
            }
            if(!map.containsKey(sum)){
                map.put(sum,i);
            }
        }
        return ans;
    }
}
```

这道题的核心思路就是:

记录每一个前缀最早出现的位置，<font color="red">但是最开始要存一个map,set(0,-1),0最早出现的位置是-1</font>

然后去遍历元素，sum记录从0到当前元素的求和值，sum-need=k,只要need存在就更新一次答案，最后返回答案

## 题目三

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的子数组的个数。

代码:

```java
import java.util.HashMap;
import java.util.Map;
// 测试链接 : https://leetcode.cn/problems/subarray-sum-equals-k/

public class Code03_Solution560 {
    public int subarraySum(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,1);
        int ans =0;
        for(int i=0,sum=0;i< nums.length;i++){
            sum += nums[i];
            //sum-need = k need -> sum-k
            ans += map.getOrDefault(sum-k,0);
            map.put(sum,map.getOrDefault(sum,0)+1);
        }
        return ans;
    }
}
```

核心:遍历以i结尾的能构成k的子数组个数

## 题目四

构建前缀和最早出现的位置。返回无序数组中正数和负数个数相等的最长子数组长度

代码:

```java
import java.io.*;
import java.util.HashMap;
import java.util.Map;

//测试链接:https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb
public class Code04_Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while (in.nextToken() !=StreamTokenizer.TT_EOF){
            int n= (int)in.nval;in.nextToken();
            int[] arr = new int[n];
            for(int i=0;i<n;i++){
                arr[i]=(int) in.nval;
                in.nextToken();
            }
            out.println(f(arr,0));
        }
        out.flush();
        out.close();
        br.close();
    }
    public static int f(int[] arr,int aim){
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        int ans = Integer.MIN_VALUE;
        for(int i=0,sum=0;i<arr.length;i++){
            if(arr[i]!=0){
                sum += arr[i]>0?1:-1;
            }
            //sum-need=aim -> need = sum-aim
            if(map.containsKey(sum-aim)){
                ans = Math.max(ans,i-map.get(sum-aim));
            }
            map.putIfAbsent(sum,i);
        }
        return ans;
    }
}
```

这道题，左神做了一个很巧妙的转换，就是正数就记为1，负数就记为-1,这样之后就是找前缀和为0的最长的子数组了，和题目二一样

## 题目五

构建前缀和最早出现的位置。表现良好的最长时间段问题。

```java
import java.util.HashMap;
import java.util.Map;

//测试链接:https://leetcode.cn/problems/longest-well-performing-interval/
public class Code05_Solution1124 {
    public int longestWPI(int[] hours) {
        Map<Integer,Integer> prefix = new HashMap<>();
        prefix.put(0,-1);
        int ans = 0;
        for (int i = 0,sum=0; i < hours.length; i++) {
            sum += (hours[i]>8?1:-1);
            if(sum>0){
                ans = i+1;
            }else{
                //need=sum-1
                if(prefix.containsKey(sum-1)){
                    ans = Math.max(ans,i- prefix.get(sum-1));
                }
                prefix.putIfAbsent(sum,i);
            }
        }
        return ans;
    }
}
```

这道题有一个精髓，sum[i]-need=aim,题目要求aim>0，所以sum[i]>need

但是我们只需要找sum[i]-1的最早出现的位置就可以了，因为<font color="red">sum[i]-n(n>1)出现之前一定会有sum[i]-1的出现，因为只有+1和-1两个数字累加</font>

## 题目六

构建前缀和余数最晚出现的位置。移除的最短子数组长度，使得剩余元素的累加和能被p整除

代码:

```java
import java.util.HashMap;
import java.util.Map;

//测试链接:https://leetcode.cn/problems/make-sum-divisible-by-p/
public class Code06_Solution1590 {
    public int minSubarray(int[] nums, int p) {
        int sum =0;
        for(int num:nums){
            sum = (sum+num)%p;
        }
        if(sum == 0) return 0;
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        int ans = nums.length;
        for (int i = 0,cur=0; i < nums.length; i++) {
            cur = (cur+nums[i])%p;
            //(cur-need+p)%p==sum
            //need = (cur-sum+p)%p
            if(map.containsKey((cur-sum+p)%p)){
                ans = Math.min(ans,i-map.get((cur-sum+p)%p));
            }
            map.put(cur,i);
        }
        return ans == nums.length?-1:ans;
    }
}
```

这道题核心就在于构造出前缀和余数最晚出现的位置，然后找寻(cur-sum+p)%p最晚出现的位置。

>  比如:p=7,整体求和%p为2
> 
> - 情况一:我们当前的前缀和余数为5,我们就去找前缀和余数为3的
> 
> - 情况二:我们当前的前缀和余数为1,我们就去找前缀和余数为6的
> 
> - 通用公式:<font color="red">need = (cur-sum+p)%p</font>

## 题目七

构建前缀奇偶状态最早出现的位置。每个原因包含偶数次的最长字串长度

代码:

```java
//测试链接:https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/
public class Code07_Solution1371 {
    public int findTheLongestSubstring(String s) {
        //aeiou 00000 -> 11111 共32种状态
        int[] map = new int[32];//map[status] = index //这种状态最早出现的索引
        Arrays.fill(map,-2);//代表这种状态不存在
        map[0]=-1;
        int ans = 0;//ans的最小值就是不存在这样的字串，字串长度为0
        for (int i = 0,status=0,offset; i < s.length(); i++) {
            offset = getOffset(s.charAt(i));
            if(offset!=-1) status ^= 1<<offset;
            if(map[status]!=-2){
                ans = Math.max(ans,i-map[status]);
            }else{
                map[status]=i;
            }
        }
        return ans;
    }
    public int getOffset(char c){
        switch (c){
            case 'a':return 0;
            case 'e':return 1;
            case 'i':return 2;
            case 'o':return 3;
            case 'u':return 4;
            default:return -1;
        }
    }
}
```

这道题核心就在于用5个bit位来表示aeiou是否是偶数，0代表当前字母已经是偶数,1代表当前字母是奇数

比如我们来到一个位置，从0到当前下标的status = 10010,我们就去找最早10010出现的位置，从最早出现的位置到当前位置就可以保证aeiou都是出现偶数次

奇数次的字母再遇到一个字母变成偶数次,偶数次的字母再遇到一个字母变成奇数次，恰好可以利用异或来模拟这个过程


