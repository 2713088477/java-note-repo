# 构建前缀信息的技巧-解决子数组相关问题

**解决如下问题，时间复杂度O(n)**

<font color="red">提示:子数组一定是连续的</font>

## 题目一

构建前缀和数组。快速解决子数组范围求和的问题

```java
//测试链接:https://leetcode.cn/problems/range-sum-query-immutable/description/
class NumArray {
    //sum[i]表示前i的数字的前缀和
    //这样设计避免了求[0,1]时候要重新写判断语句
    public int[] sum;

    public NumArray(int[] nums) {
        int len=nums.length;
        sum = new int[len+1];
        for(int i=1;i<=len;i++){
            sum[i]=sum[i-1]+nums[i-1];
        }
    }

    public int sumRange(int left, int right) {
        return sum[right+1]-sum[left];
    }
}
```

## 题目二

构建前缀和最早出现的位置。返回无序数组中累加和为给定值的最长子数组长度。

```java
import java.io.*;
import java.util.Map;
import java.util.HashMap;
// 测试链接 : https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while(in.nextToken() != StreamTokenizer.TT_EOF){
            int n = (int)in.nval;in.nextToken();
            int k = (int)in.nval;in.nextToken();
            int[] arr= new int[n];
            for(int i=0;i<n;i++){
                arr[i]=(int)in.nval;
                in.nextToken();
            }
            out.println(f(arr,k));
        }
        out.flush();
        out.close();
        br.close();
    }
    public static int f(int[] arr,int k){
        int ans = Integer.MIN_VALUE;
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        for(int i=0,sum=0;i<arr.length;i++){
            sum += arr[i];
            //sum-need=k;
            if(map.containsKey(sum-k)){
                ans=Math.max(ans,i-map.get(sum-k));
            }
            if(!map.containsKey(sum)){
                map.put(sum,i);
            }
        }
        return ans;
    }
}
```

这道题的核心思路就是:

记录每一个前缀最早出现的位置，<font color="red">但是最开始要存一个map,set(0,-1),0最早出现的位置是-1</font>

然后去遍历元素，sum记录从0到当前元素的求和值，sum-need=k,只要need存在就更新一次答案，最后返回答案

## 题目三

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的子数组的个数。

代码:

```java
import java.util.HashMap;
import java.util.Map;
// 测试链接 : https://leetcode.cn/problems/subarray-sum-equals-k/

public class Code03_Solution560 {
    public int subarraySum(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,1);
        int ans =0;
        for(int i=0,sum=0;i< nums.length;i++){
            sum += nums[i];
            //sum-need = k need -> sum-k
            ans += map.getOrDefault(sum-k,0);
            map.put(sum,map.getOrDefault(sum,0)+1);
        }
        return ans;
    }
}
```

核心:遍历以i结尾的能构成k的子数组个数

## 题目四

构建前缀和最早出现的位置。返回无序数组中正数和负数个数相等的最长子数组长度

代码:

```java
import java.io.*;
import java.util.HashMap;
import java.util.Map;

//测试链接:https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb
public class Code04_Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while (in.nextToken() !=StreamTokenizer.TT_EOF){
            int n= (int)in.nval;in.nextToken();
            int[] arr = new int[n];
            for(int i=0;i<n;i++){
                arr[i]=(int) in.nval;
                in.nextToken();
            }
            out.println(f(arr,0));
        }
        out.flush();
        out.close();
        br.close();
    }
    public static int f(int[] arr,int aim){
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        int ans = Integer.MIN_VALUE;
        for(int i=0,sum=0;i<arr.length;i++){
            if(arr[i]!=0){
                sum += arr[i]>0?1:-1;
            }
            //sum-need=aim -> need = sum-aim
            if(map.containsKey(sum-aim)){
                ans = Math.max(ans,i-map.get(sum-aim));
            }
            map.putIfAbsent(sum,i);
        }
        return ans;
    }
}
```

这道题，左神做了一个很巧妙的转换，就是正数就记为1，负数就记为-1,这样之后就是找前缀和为0的最长的子数组了，和题目二一样


