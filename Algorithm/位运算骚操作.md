# 位运算骚操作

## 为啥要学这个？

因为赋值语句，位运算，算术运算的的速度>条件判断和循环语句的速度

## 1.判断一个数是不是2的幂

思路:提取出一个最右侧的1，看看和原数是否相同

```java
public boolean isPowerOfTwo(int n) {
    return n>0 && n == (n&(~n+1));
}
```

测试链接:[231. 2 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-two/)

## 2.判断一个数是不是3的幂

这道题其实是考验数学思维，我们假设一个数为$$3^m$$

如果一个数x，$$3^m$$%x==0，说明x一定是3的幂

所以我们需要提前知道在int范围内最大的3的幂是谁？

```java
public static void main(String[] args) {
    //找到int范围内最大的3的幂 1 3 9 27 27*3
    int ans=1;
    while(ans*3>0&&ans*3<=Integer.MAX_VALUE) {
        ans*=3;
    }
    System.out.println(ans);//1162261467

}
public boolean isPowerOfThree(int n) {
    return n>0 && 1162261467%n==0;
}
```

## 3.返回大于等于n的最小的2的幂

思想:

1.n=n-1 防止n本身就是2的幂

2.n |= n>>>1 从左边第一个1开始，会刷出2个1

   n |= n>>>2 从刚刚的2个1，会刷出4个1

   n |= n>>>4 从刚刚的4个1，会刷出8个1

   n |= n>>>8 从刚刚的8个1，会刷出16个1

   n |= n>>>16 从刚刚的16个1，会刷出32个1

 3.return n+1

```java
//如果int范围内没有出现这样的数，返回整数最小值
public static int Near2Power(int n) {
    n--;
    n |= n>>>1;
    n |= n>>>2;
    n |= n>>>4;
    n |= n>>>8;
    n |= n>>>16;
    return n+1;
}
```

## 4.返回[left,right]数字范围与

注意这个题目的意思是返回[left,right]这一段连续数字的按位与

这道题思路不难想，如果是纯暴力的话，会超时，因为left=1,right=Integer.MAX_VALUE的时候会超时

举两个例子就明白了

比如[5,7]

0111 & 0110 =0110

0110 & 0101=0100

所以发现:每次按位与的结果就是最右边的1变为了0，只要right>left，就需要把最右边的1变为0

我写的代码如下:

```java
public int rangeBitwiseAnd(int left, int right) {
    while(right>left){
    right ^= (right&(~right+1));
    }
    return right;
}
```

左神的代码如下:

```java
public static int rangeBitwiseAnd(int left, int right) {
    while (left < right) {
    right -= right & -right;
    }
    return right;
}
```

所以感觉num1-num2  <=> num1^num2，有待证实

好吧，通义说不等价，还是以左神的为主，我的可能只是恰巧正确

## 5.逆序一个二进制序列

题意很简单:就是将一个32位int的序列，逆序,暴力做法如下:

```java
public int reverseBits(int n) {
    int ans=0;
    for(int i=31;i>=0;i--){
        int num=31-i;
        int temp= n & (1<<num);
        if(temp!=0){
            ans |= (1<<i);
        }
    }
    return ans;
}
```

左神的思路像是归并思想:

比如abcd -> dcba

cd ab(先将两个整体逆序) -> dc ba(再对单个整体再次逆序)

写程序反着来

1.先一一逆序

n = ((n&(0xaaaaaaaa)) >>> 1) | ((n&(0x55555555)) << 1);

10->01 01->10 00->00 11->11

2.再两两逆序

n = ((n&(0xcccccccc)) >>> 2) | ((n&(0x33333333)) << 2);

abcd ->cdab

3.再四四逆序

n = ((n&(0xf0f0f0f0)) >>> 4) | ((n&(0x0f0f0f0f)) << 4);

abcdefgh -> efghabcd

4.再八八逆序

n = ((n&(0xff00ff00)) >>> 8) | ((n&(0x00ff00ff)) << 8);

5.再十六十六逆序

n = ((n&(0xffff0000)) >>> 16) | ((n&(0x0000ffff)) << 16);

代码展示:

```java
public static int reverseBits(int n) {
    n = ((n&(0xaaaaaaaa)) >>> 1) | ((n&(0x55555555)) << 1);
    n = ((n&(0xcccccccc)) >>> 2) | ((n&(0x33333333)) << 2);
    n = ((n&(0xf0f0f0f0)) >>> 4) | ((n&(0x0f0f0f0f)) << 4);
    n = ((n&(0xff00ff00)) >>> 8) | ((n&(0x00ff00ff)) << 8);
    n = ((n&(0xffff0000)) >>> 16) | ((n&(0x0000ffff)) << 16);
    return n;
}
```

## 6.返回一个数二进制中有几个1

暴力做法:

```java
public static int count(int num) {
    int ans=0;
    while(num!=0) {
        num=num ^ (num&(~num+1));;
        ans++;
    }
    return ans;
}
```







