# 登录认证

## 1.基础理念

登录认证说到低就是查询，**select * from user where username = #{username} and password = #{password}**

如果查到了就说明是正确登录的，否则就是错误的

## 2.登录校验

首先我们要清楚，http协议是<font color="red">无状态</font>的协议，啥是无状态的，请求之间是毫无关联的，这一次的请求不记得上一次的请求。

我们的某些功能，也可以说是某些接口，是不允许用户没有登录访问的，同时如果用户登录了，我们也必须记住这次这个**登录状态**。

这就引出了登录校验我认为最核心的——**<font color="red">会话技术</font>**

### 1.会话技术

会话:顾名思义就是一次对话，从用户打开了网页开始，直到关闭这个网页或者浏览器，之间用户所有的请求都是处于一个会话中

可是我们的浏览器和服务端是怎么知道这是一个请求呢？

有三种方案:

**1.cookie**

**2.session**

**3.令牌技术**

#### 1.cookie

cookie是浏览器自带的客户端会话跟踪技术,这个技术是基于http请求的，所以作为开发人员这个技术挺方便的。

后端请求代码:

```java
@RestController
@AllArgsConstructor
@Slf4j
public class UserController {
    private final IUserService userService;
    @GetMapping("/c1")
    public String setCookie(HttpServletResponse response){
        response.addCookie(new Cookie("username","yiyi"));
        return "ok";
    }
    @GetMapping("/c2")
    public String getCookie(HttpServletRequest request){
        Cookie[] cookies = request.getCookies();
        for (Cookie cookie : cookies) {
            if(cookie.getName().equals("username")){
                log.info("cookie:{}",cookie.getValue());
            }
        }
        return "ok";
    }
}
```

当浏览器访问这个请求的时候，会自动把这个cookie解析出来保存

![](assets/后端增加cookie.png)

 当我们访问其他接口的时候，cookie就会自动携带到请求中

比如在getCookie中就可以获取到请求中的cookie。

**<font color="red">cookie的三个自动:</font>**

<font color="red">1.服务器会自动的将cookie响应给浏览器</font>

<font color="red">2.浏览器接收到响应回来的数据之后，会自动的将cookie存储到浏览器本地</font>

<font color="red">3.在后续的请求当中，浏览器会自动的将cookie携带到服务器端</font>

优缺点:

优点:Http协议中支持的技术(像set-cookie响应头的解析以及Cookie请求头数据的携带，都是浏览器自动进行的)

缺点:

1. 移动端App(Android、iOS)中无法使用Cookie

2. 不安全，用户可以自己禁用Cookie

3. Cookie不能跨域

**跨域:** 跨域是一个浏览器安全概念，指的是在不符合同源策略的情况下，前端JavaScript代码无法直接请求其他域的资源，需要服务器端配合或采用其他技术手段来解决

区分跨域的三个维度:

1. ip

2. 协议

3. 端口

#### 2.session

session是在服务器端的会话跟踪技术，他是存储在服务端的，底层也是基于cookie。

代码:

```java
@Slf4j
@RestController
public class SessionController {
    @GetMapping("/s1")
    public String setSession(HttpSession session){
        log.info("session:{}",session);
        session.setAttribute("username","yiyi");
        return "ok";
    }
    @GetMapping("/s2")
    public String getSession(HttpServletRequest request){
        HttpSession session = request.getSession();
        log.info("session:{}",session);
        Object username = session.getAttribute("username");
        log.info("username:{}",username);
        return "ok";
    }
}
```

当我们在浏览器访问如果是第一次访问s1的时候，就会在在响应头中有一个`set-cookie JSESSIONID=FC2923AE27D354FC6C3498E2F9C992F1; Path=/; HttpOnly `

![](assets/第一次获取到session.png)

此时浏览器就会自动把cookie存起来，下次请求的时候就会携带过去

![](assets/携带jsessionid.png)

**<font color="red">Session存储的优缺点:</font>**

**优点:** Session是存储在服务端的，安全

**缺点:** 

1. 服务器集群环境下无法直接使用Session

2. 移动端App(Android,IOS)中无法使用Cookie

3. 用户可以自己禁用Cookie

4. Cookie不能跨域

**Session底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了**

#### 3.令牌技术

令牌技术很简单，相当于一个身份证，登录成功之后，服务端返回一个令牌(一般是一个字符串)，浏览器将其存储起来,然后每次请求的时候携带上这个字符串，服务端就可以校验和知道这个身份了。

**<font color="red">令牌技术的优缺点:</font>**

**优点:**

1.支持PC端，移动端

2.解决集群环境下的认证问题

3.减轻服务器的存储压力(无需再服务端存储)

**缺点:** 需要自己实现(包括令牌的生成，令牌的传递，令牌的校验)



这里我们介绍最为流行的**JWT令牌**

JWT令牌一共由三个部分组成

![](assets/JWT组成.png)

每个部分之间用"."分割，第一部分是指定签名算法和令牌类型，第二部分是我们存入的键值对的声明，第三部分是签名密钥

这个JWT令牌的生成，就是把头部和载荷转为json,对这个json进行**Base64url编码**,只要第三部分需要对前面的两部分连起来然后利用密钥进行签名

**<font color="red">前面两部分都是Base64url编码，最后一部分是校验看数据有没有被恶意改动过</font>**



**使用jwt的步骤:**

这里我使用hutool包里面的Jwt工具类

1.引入依赖

```xml
<dependency>
   <groupId>cn.hutool</groupId>
   <artifactId>hutool-all</artifactId>
   <version>5.8.16</version>
</dependency>
```

2.生成和解析

```java
    @Test
    public void testCreateJWT(){
        Map<String, Object> headers = Map.of("typ", "JWT", "alg", "HS256");
        Map<String, Object> payload = Map.of("username", "yiyi");
        byte[] key = "yiyi".getBytes();
        String token = JWTUtil.createToken(headers, payload, key);
        System.out.println(token);

    }
    @Test
    public void testParseJWT(){
        String token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InlpeWkifQ._GUOlud4bmXenNWlmNFzY507t5Kwd8JTacEb_WI_Xds";
        JWT jwt = JWTUtil.parseToken(token);
        boolean verify = jwt.setKey("yiyi".getBytes()).verify();
        System.out.println(verify);

    }
```

### 2.统一拦截技术

会话技术相当于给了前端一个身份证，而我们后端还需要对每张"身份证"进行校验，校验通过了，才放行。

这就需要用到**统一拦截技术**

#### 1.Filter过滤器

什么是filter?

filter标示过滤器，是JavaWeb三大组件(Servlet,Filter,Listener)之一

过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。

使用了过滤器之后，要想访问web服务器上的资源，必须先经过过滤器，过滤器处理完毕之后，才可以访问对应的资源。

过滤器一般完成一些通用的操作，比如:登录校验，统一编码处理，敏感字符处理等。



**使用步骤:**

1.实现Filter类，重写三个方法

```java
@Slf4j
@WebFilter(urlPatterns = "/*")
public class LoginFilter implements Filter {
    // 初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
        log.info("初始化LoginFilter");
    }
    // 拦截到请求时,调用该方法,可以调用多次
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("放行前:{}",servletRequest.getRemoteAddr());
        filterChain.doFilter(servletRequest,servletResponse);//放行
        log.info("放行后:{}",servletRequest.getRemoteAddr());
    }

    // 销毁方法, web服务器关闭时调用, 只调用一次
    @Override
    public void destroy() {
        Filter.super.destroy();
        log.info("销毁LoginFilter");
    }
}
```

2.在刚刚的类上加上@WebFilter注解，并在urlPatterns属性上面写好拦截的路径

启动类上加上@ServletComponentScan 

```java
@SpringBootApplication
@ServletComponentScan //开启对Servlet组件的支持
@MapperScan("com.hao.mapper")
public class StudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(StudyApplication.class, args);
    }
}
```



**过滤器的拦截路径**

<table>
<tr>
    <th>拦截路径</th>
    <th>urlPatterns值</th>
</tr>
<tr>
    <td>拦截具体路径</td>
    <td>/login</td>
</tr>
<tr>
    <td>目录拦截</td>
    <td>/emps/*</td>
</tr>
<tr>
    <td>拦截所有</td>
    <td>/*</td>
</tr>
</table>

**过滤器链**

过滤器链指的是在一个web应用程序当中，可以配置多个过滤器，多个过滤器就形成了一个过滤器链。

![](assets/过滤器链.png)

<font color="red">注解配置的Filter,优先级是按照过滤器类名(字符串)的自然排序</font>

#### 2.拦截器Interceptor

**什么是拦截器?**

1. 是一种动态拦截方法调用的机制，类似于过滤器

2. 拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行

3. 拦截器的作用:拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码

**拦截器的使用步骤:**

1. 定义拦截器

```java
@Component
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    //目标资源方法执行前执行。 返回true：放行    返回false：不放行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info("放行前---------");
        return true;//放行
    }
    //目标资源方法执行后执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
        log.info("放行后");
    }
    //视图渲染完毕后执行，最后执行
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
        log.info("视图渲染完成");
    }
}
```

2. 注册配置拦截器

创建一个配置类，实现`WebMvcConfigurer`接口，并重写addInterceptors方法

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Autowired
    private LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor);
    }
}

```

**拦截路径:**

可以配置addInterceptor("要拦截的路径")和excludePathPatterns("不拦截路径")

| 拦截路径        | 含义               | 举例                                                    |
| ----------- | ---------------- | ----------------------------------------------------- |
| `/*`        | 一级路径             | 能匹配 `/depts`, `/emps`, `/login`，不能匹配 `/depts/1`       |
| `/**`       | 任意级路径            | 能匹配 `/depts`, `/depts/1`, `/depts/1/2`                |
| `/depts/*`  | `/depts` 下的一级路径  | 能匹配 `/depts/1`，不能匹配 `/depts/1/2`、`/depts`             |
| `/depts/**` | `/depts` 下的任意级路径 | 能匹配 `/depts`, `/depts/1`, `/depts/1/2`，不能匹配 `/emps/1` |

**执行流程:**

![](assets/拦截器执行流程.png)



- Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。
- 在controller当中的方法执行完毕之后，再回过来执行`postHandle()`这个方法以及`afterCompletion()` 方法，然后再返回给DispatcherServlet，最终再来执行过滤器当中放行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。


